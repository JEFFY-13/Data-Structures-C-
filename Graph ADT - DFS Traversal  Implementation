//Graph ADT - DFS Traversal  Implementation
#include <iostream>
using namespace std;
#define MAX 20
class Graph {
private:
    struct Node {
        int vertex;
        Node* next;
    };
    Node* G[MAX];       
    bool visited[MAX];  
    int vertices;
public:
    Graph(int v);                
    Node* createNode(int v); 
    void addEdges(int edges[][2], int e); 
    void insert(int vs, int vd); 
    void DFS(int source);       
};
Graph::Node* Graph::createNode(int v) {
    Node* newNode = new Node;
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}
Graph::Graph(int v) : vertices(v) {
    for (int i = 0; i < v; i++) {
        G[i] = NULL;
        visited[i] = false;
    }
}
void Graph::addEdges(int edges[][2], int e) {
    for (int i = 0; i < e; i++) {
        int vs = edges[i][0];
        int vd = edges[i][1];
        insert(vs, vd); 
    }
}
void Graph::insert(int vs, int vd) {
    Node* temp = createNode(vd); 
    if (G[vs] == NULL) {
        G[vs] = temp; 
        return;
    } 
        Node* p = G[vs];
        while (p->next != NULL) 
            p = p->next;
        p->next = temp;
}
void Graph::DFS(int source) {
    cout << source << " --> ";
    visited[source] = true;
    Node* p = G[source];
    while (p != NULL) {
        int vertex = p->vertex;
        if (!visited[vertex]) 
            DFS(vertex); 
        p = p->next;
    }
}
int main() {
    int vertices = 5;
    Graph graph(vertices);
    int edges[][2] = {
        {0, 1},
        {0, 2},
        {1, 3},
        {1, 4},
        {2, 4},
        {3, 4}
    };
    int numEdges = 6;
    //int numEdges = sizeof(edges) / sizeof(edges[0]);
    graph.addEdges(edges, numEdges);
    int source = 0; // Define the source vertex for DFS
    cout << "\nDFS Traversal from vertex " << source << ":\n";
    graph.DFS(source);
    return 0;
}
